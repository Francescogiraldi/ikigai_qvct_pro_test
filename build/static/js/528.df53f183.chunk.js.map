{"version":3,"file":"static/js/528.df53f183.chunk.js","mappings":"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","sources":["../node_modules/process/browser.js","../node_modules/@gradio/client/dist/index.js"],"sourcesContent":["// shim for using process in browser\n// based on https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\nif (typeof global.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout;\n}\nif (typeof global.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout;\n}\n\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\nmodule.exports = process;","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _currentLine;\nvar fn = new Intl.Collator(0, { numeric: 1 }).compare;\nfunction semiver(a, b, bool) {\n  a = a.split(\".\");\n  b = b.split(\".\");\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\n}\nconst HOST_URL = `host`;\nconst SSE_URL = `queue/data`;\nconst SSE_DATA_URL = `queue/join`;\nconst UPLOAD_URL = `upload`;\nconst LOGIN_URL = `login`;\nconst CONFIG_URL = `config`;\nconst API_INFO_URL = `info`;\nconst RUNTIME_URL = `runtime`;\nconst SLEEPTIME_URL = `sleeptime`;\nconst HEARTBEAT_URL = `heartbeat`;\nconst COMPONENT_SERVER_URL = `component_server`;\nconst RESET_URL = `reset`;\nconst CANCEL_URL = `cancel`;\nconst SPACE_FETCHER_URL = \"https://gradio-space-api-fetcher-v2.hf.space/api\";\nconst QUEUE_FULL_MSG = \"This application is currently busy. Please try again. \";\nconst BROKEN_CONNECTION_MSG = \"Connection errored out. \";\nconst CONFIG_ERROR_MSG = \"Could not resolve app config. \";\nconst SPACE_STATUS_ERROR_MSG = \"Could not get space status. \";\nconst API_INFO_ERROR_MSG = \"Could not get API info. \";\nconst SPACE_METADATA_ERROR_MSG = \"Space metadata could not be loaded. \";\nconst INVALID_URL_MSG = \"Invalid URL. A full URL path is required.\";\nconst UNAUTHORIZED_MSG = \"Not authorized to access this space. \";\nconst INVALID_CREDENTIALS_MSG = \"Invalid credentials. Could not login. \";\nconst MISSING_CREDENTIALS_MSG = \"Login credentials are required to access this space.\";\nconst NODEJS_FS_ERROR_MSG = \"File system access is only available in Node.js environments\";\nconst ROOT_URL_ERROR_MSG = \"Root URL not found in client config\";\nconst FILE_PROCESSING_ERROR_MSG = \"Error uploading file\";\nfunction resolve_root(base_url, root_path, prioritize_base) {\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\n    return prioritize_base ? base_url : root_path;\n  }\n  return base_url + root_path;\n}\nasync function get_jwt(space, token, cookies) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        ...cookies ? { Cookie: cookies } : {}\n      }\n    });\n    const jwt = (await r.json()).token;\n    return jwt || false;\n  } catch (e) {\n    return false;\n  }\n}\nfunction map_names_to_ids(fns) {\n  let apis = {};\n  fns.forEach(({ api_name, id }) => {\n    if (api_name)\n      apis[api_name] = id;\n  });\n  return apis;\n}\nasync function resolve_config(endpoint) {\n  var _a;\n  const headers = this.options.hf_token ? { Authorization: `Bearer ${this.options.hf_token}` } : {};\n  headers[\"Content-Type\"] = \"application/json\";\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n    const path = window.gradio_config.root;\n    const config = window.gradio_config;\n    let config_root = resolve_root(endpoint, config.root, false);\n    config.root = config_root;\n    return { ...config, path };\n  } else if (endpoint) {\n    let config_url = join_urls(\n      endpoint,\n      this.deep_link ? CONFIG_URL + \"?deep_link=\" + this.deep_link : CONFIG_URL\n    );\n    const response = await this.fetch(config_url, {\n      headers,\n      credentials: \"include\"\n    });\n    if ((response == null ? void 0 : response.status) === 401 && !this.options.auth) {\n      throw new Error(MISSING_CREDENTIALS_MSG);\n    } else if ((response == null ? void 0 : response.status) === 401 && this.options.auth) {\n      throw new Error(INVALID_CREDENTIALS_MSG);\n    }\n    if ((response == null ? void 0 : response.status) === 200) {\n      let config = await response.json();\n      config.path = config.path ?? \"\";\n      config.root = endpoint;\n      (_a = config.dependencies) == null ? void 0 : _a.forEach((dep, i) => {\n        if (dep.id === void 0) {\n          dep.id = i;\n        }\n      });\n      return config;\n    } else if ((response == null ? void 0 : response.status) === 401) {\n      throw new Error(UNAUTHORIZED_MSG);\n    }\n    throw new Error(CONFIG_ERROR_MSG);\n  }\n  throw new Error(CONFIG_ERROR_MSG);\n}\nasync function resolve_cookies() {\n  const { http_protocol, host } = await process_endpoint(\n    this.app_reference,\n    this.options.hf_token\n  );\n  try {\n    if (this.options.auth) {\n      const cookie_header = await get_cookie_header(\n        http_protocol,\n        host,\n        this.options.auth,\n        this.fetch,\n        this.options.hf_token\n      );\n      if (cookie_header)\n        this.set_cookies(cookie_header);\n    }\n  } catch (e) {\n    throw Error(e.message);\n  }\n}\nasync function get_cookie_header(http_protocol, host, auth, _fetch, hf_token) {\n  const formData = new FormData();\n  formData.append(\"username\", auth == null ? void 0 : auth[0]);\n  formData.append(\"password\", auth == null ? void 0 : auth[1]);\n  let headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const res = await _fetch(`${http_protocol}//${host}/${LOGIN_URL}`, {\n    headers,\n    method: \"POST\",\n    body: formData,\n    credentials: \"include\"\n  });\n  if (res.status === 200) {\n    return res.headers.get(\"set-cookie\");\n  } else if (res.status === 401) {\n    throw new Error(INVALID_CREDENTIALS_MSG);\n  } else {\n    throw new Error(SPACE_METADATA_ERROR_MSG);\n  }\n}\nfunction determine_protocol(endpoint) {\n  if (endpoint.startsWith(\"http\")) {\n    const { protocol, host, pathname } = new URL(endpoint);\n    return {\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: protocol,\n      host: host + (pathname !== \"/\" ? pathname : \"\")\n    };\n  } else if (endpoint.startsWith(\"file:\")) {\n    return {\n      ws_protocol: \"ws\",\n      http_protocol: \"http:\",\n      host: \"lite.local\"\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\n    };\n  }\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: new URL(endpoint).host\n  };\n}\nconst parse_and_set_cookies = (cookie_header) => {\n  let cookies = [];\n  const parts = cookie_header.split(/,(?=\\s*[^\\s=;]+=[^\\s=;]+)/);\n  parts.forEach((cookie) => {\n    const [cookie_name, cookie_value] = cookie.split(\";\")[0].split(\"=\");\n    if (cookie_name && cookie_value) {\n      cookies.push(`${cookie_name.trim()}=${cookie_value.trim()}`);\n    }\n  });\n  return cookies;\n};\nconst RE_SPACE_NAME = /^[a-zA-Z0-9_\\-\\.]+\\/[a-zA-Z0-9_\\-\\.]+$/;\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}.*$/;\nasync function process_endpoint(app_reference, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const _app_reference = app_reference.trim().replace(/\\/$/, \"\");\n  if (RE_SPACE_NAME.test(_app_reference)) {\n    try {\n      const res = await fetch(\n        `https://huggingface.co/api/spaces/${_app_reference}/${HOST_URL}`,\n        { headers }\n      );\n      const _host = (await res.json()).host;\n      return {\n        space_id: app_reference,\n        ...determine_protocol(_host)\n      };\n    } catch (e) {\n      throw new Error(SPACE_METADATA_ERROR_MSG);\n    }\n  }\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\n    const { ws_protocol, http_protocol, host } = determine_protocol(_app_reference);\n    return {\n      space_id: host.split(\"/\")[0].replace(\".hf.space\", \"\"),\n      ws_protocol,\n      http_protocol,\n      host\n    };\n  }\n  return {\n    space_id: false,\n    ...determine_protocol(_app_reference)\n  };\n}\nconst join_urls = (...urls) => {\n  try {\n    return urls.reduce((base_url, part) => {\n      base_url = base_url.replace(/\\/+$/, \"\");\n      part = part.replace(/^\\/+/, \"\");\n      return new URL(part, base_url + \"/\").toString();\n    });\n  } catch (e) {\n    throw new Error(INVALID_URL_MSG);\n  }\n};\nfunction transform_api_info(api_info, config, api_map) {\n  const transformed_info = {\n    named_endpoints: {},\n    unnamed_endpoints: {}\n  };\n  Object.keys(api_info).forEach((category) => {\n    if (category === \"named_endpoints\" || category === \"unnamed_endpoints\") {\n      transformed_info[category] = {};\n      Object.entries(api_info[category]).forEach(\n        ([endpoint, { parameters, returns }]) => {\n          var _a, _b, _c, _d;\n          const dependencyIndex = ((_a = config.dependencies.find(\n            (dep) => dep.api_name === endpoint || dep.api_name === endpoint.replace(\"/\", \"\")\n          )) == null ? void 0 : _a.id) || api_map[endpoint.replace(\"/\", \"\")] || -1;\n          const dependencyTypes = dependencyIndex !== -1 ? (_b = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _b.types : { generator: false, cancel: false };\n          if (dependencyIndex !== -1 && ((_d = (_c = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _c.inputs) == null ? void 0 : _d.length) !== parameters.length) {\n            const components = config.dependencies.find((dep) => dep.id == dependencyIndex).inputs.map(\n              (input) => {\n                var _a2;\n                return (_a2 = config.components.find((c) => c.id === input)) == null ? void 0 : _a2.type;\n              }\n            );\n            try {\n              components.forEach((comp, idx) => {\n                if (comp === \"state\") {\n                  const new_param = {\n                    component: \"state\",\n                    example: null,\n                    parameter_default: null,\n                    parameter_has_default: true,\n                    parameter_name: null,\n                    hidden: true\n                  };\n                  parameters.splice(idx, 0, new_param);\n                }\n              });\n            } catch (e) {\n              console.error(e);\n            }\n          }\n          const transform_type = (data, component, serializer, signature_type) => ({\n            ...data,\n            description: get_description(data == null ? void 0 : data.type, serializer),\n            type: get_type(data == null ? void 0 : data.type, component, serializer, signature_type) || \"\"\n          });\n          transformed_info[category][endpoint] = {\n            parameters: parameters.map(\n              (p) => transform_type(p, p == null ? void 0 : p.component, p == null ? void 0 : p.serializer, \"parameter\")\n            ),\n            returns: returns.map(\n              (r) => transform_type(r, r == null ? void 0 : r.component, r == null ? void 0 : r.serializer, \"return\")\n            ),\n            type: dependencyTypes\n          };\n        }\n      );\n    }\n  });\n  return transformed_info;\n}\nfunction get_type(type, component, serializer, signature_type) {\n  if (component === \"Api\")\n    return type.type;\n  switch (type == null ? void 0 : type.type) {\n    case \"string\":\n      return \"string\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n  }\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\n    return \"any\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"string[]\";\n  } else if (component === \"Image\") {\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n  } else if (serializer === \"FileSerializable\") {\n    if ((type == null ? void 0 : type.type) === \"array\") {\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n    }\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n  } else if (serializer === \"GallerySerializable\") {\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n  }\n}\nfunction get_description(type, serializer) {\n  if (serializer === \"GallerySerializable\") {\n    return \"array of [file, label] tuples\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"array of strings\";\n  } else if (serializer === \"FileSerializable\") {\n    return \"array of files or single file\";\n  }\n  return type == null ? void 0 : type.description;\n}\nfunction handle_message(data, last_status) {\n  const queue = true;\n  switch (data.msg) {\n    case \"send_data\":\n      return { type: \"data\" };\n    case \"send_hash\":\n      return { type: \"hash\" };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          message: QUEUE_FULL_MSG,\n          stage: \"error\",\n          code: data.code,\n          success: data.success\n        }\n      };\n    case \"heartbeat\":\n      return {\n        type: \"heartbeat\"\n      };\n    case \"unexpected_error\":\n      return {\n        type: \"unexpected_error\",\n        status: {\n          queue,\n          message: data.message,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: last_status || \"pending\",\n          code: data.code,\n          size: data.queue_size,\n          position: data.rank,\n          eta: data.rank_eta,\n          success: data.success\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          progress_data: data.progress_data,\n          success: data.success\n        }\n      };\n    case \"log\":\n      return { type: \"log\", data };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : null,\n          stage: data.success ? \"generating\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.average_duration,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_streaming\":\n      return {\n        type: \"streaming\",\n        status: {\n          queue,\n          message: data.output.error,\n          stage: \"streaming\",\n          time_limit: data.time_limit,\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.eta\n        },\n        data: data.output\n      };\n    case \"process_completed\":\n      if (\"error\" in data.output) {\n        return {\n          type: \"update\",\n          status: {\n            queue,\n            title: data.output.title,\n            message: data.output.error,\n            visible: data.output.visible,\n            duration: data.output.duration,\n            stage: \"error\",\n            code: data.code,\n            success: data.success\n          }\n        };\n      }\n      return {\n        type: \"complete\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : void 0,\n          stage: data.success ? \"complete\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          size: data.rank,\n          position: 0,\n          success: data.success,\n          eta: data.eta\n        },\n        original_msg: \"process_starts\"\n      };\n  }\n  return { type: \"none\", status: { stage: \"error\", queue } };\n}\nconst map_data_to_params = (data = [], endpoint_info) => {\n  const parameters = endpoint_info ? endpoint_info.parameters : [];\n  if (Array.isArray(data)) {\n    if (data.length > parameters.length) {\n      console.warn(\"Too many arguments provided for the endpoint.\");\n    }\n    return data;\n  }\n  const resolved_data = [];\n  const provided_keys = Object.keys(data);\n  parameters.forEach((param, index) => {\n    if (data.hasOwnProperty(param.parameter_name)) {\n      resolved_data[index] = data[param.parameter_name];\n    } else if (param.parameter_has_default) {\n      resolved_data[index] = param.parameter_default;\n    } else {\n      throw new Error(\n        `No value provided for required parameter: ${param.parameter_name}`\n      );\n    }\n  });\n  provided_keys.forEach((key) => {\n    if (!parameters.some((param) => param.parameter_name === key)) {\n      throw new Error(\n        `Parameter \\`${key}\\` is not a valid keyword argument. Please refer to the API for usage.`\n      );\n    }\n  });\n  resolved_data.forEach((value, idx) => {\n    if (value === void 0 && !parameters[idx].parameter_has_default) {\n      throw new Error(\n        `No value provided for required parameter: ${parameters[idx].parameter_name}`\n      );\n    }\n  });\n  return resolved_data;\n};\nasync function view_api() {\n  if (this.api_info)\n    return this.api_info;\n  const { hf_token } = this.options;\n  const { config } = this;\n  const headers = { \"Content-Type\": \"application/json\" };\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  if (!config) {\n    return;\n  }\n  try {\n    let response;\n    let api_info;\n    if (typeof window !== \"undefined\" && window.gradio_api_info) {\n      api_info = window.gradio_api_info;\n    } else {\n      if (semiver((config == null ? void 0 : config.version) || \"2.0.0\", \"3.30\") < 0) {\n        response = await this.fetch(SPACE_FETCHER_URL, {\n          method: \"POST\",\n          body: JSON.stringify({\n            serialize: false,\n            config: JSON.stringify(config)\n          }),\n          headers,\n          credentials: \"include\"\n        });\n      } else {\n        const url = join_urls(config.root, this.api_prefix, API_INFO_URL);\n        response = await this.fetch(url, {\n          headers,\n          credentials: \"include\"\n        });\n      }\n      if (!response.ok) {\n        throw new Error(BROKEN_CONNECTION_MSG);\n      }\n      api_info = await response.json();\n    }\n    if (\"api\" in api_info) {\n      api_info = api_info.api;\n    }\n    if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\n      api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n    }\n    return transform_api_info(api_info, config, this.api_map);\n  } catch (e) {\n    throw new Error(\"Could not get API info. \" + e.message);\n  }\n}\nasync function upload_files(root_url, files, upload_id) {\n  var _a;\n  const headers = {};\n  if ((_a = this == null ? void 0 : this.options) == null ? void 0 : _a.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  const chunkSize = 1e3;\n  const uploadResponses = [];\n  let response;\n  for (let i = 0; i < files.length; i += chunkSize) {\n    const chunk = files.slice(i, i + chunkSize);\n    const formData = new FormData();\n    chunk.forEach((file) => {\n      formData.append(\"files\", file);\n    });\n    try {\n      const upload_url = upload_id ? `${root_url}${this.api_prefix}/${UPLOAD_URL}?upload_id=${upload_id}` : `${root_url}${this.api_prefix}/${UPLOAD_URL}`;\n      response = await this.fetch(upload_url, {\n        method: \"POST\",\n        body: formData,\n        headers,\n        credentials: \"include\"\n      });\n    } catch (e) {\n      throw new Error(BROKEN_CONNECTION_MSG + e.message);\n    }\n    if (!response.ok) {\n      const error_text = await response.text();\n      return { error: `HTTP ${response.status}: ${error_text}` };\n    }\n    const output = await response.json();\n    if (output) {\n      uploadResponses.push(...output);\n    }\n  }\n  return { files: uploadResponses };\n}\nasync function upload(file_data, root_url, upload_id, max_file_size) {\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(\n    (file_data2) => file_data2.blob\n  );\n  const oversized_files = files.filter(\n    (f) => f.size > (max_file_size ?? Infinity)\n  );\n  if (oversized_files.length) {\n    throw new Error(\n      `File size exceeds the maximum allowed size of ${max_file_size} bytes: ${oversized_files.map((f) => f.name).join(\", \")}`\n    );\n  }\n  return await Promise.all(\n    await this.upload_files(root_url, files, upload_id).then(\n      async (response) => {\n        if (response.error) {\n          throw new Error(response.error);\n        } else {\n          if (response.files) {\n            return response.files.map((f, i) => {\n              const file = new FileData({\n                ...file_data[i],\n                path: f,\n                url: `${root_url}${this.api_prefix}/file=${f}`\n              });\n              return file;\n            });\n          }\n          return [];\n        }\n      }\n    )\n  );\n}\nasync function prepare_files(files, is_stream) {\n  return files.map(\n    (f) => new FileData({\n      path: f.name,\n      orig_name: f.name,\n      blob: f,\n      size: f.size,\n      mime_type: f.type,\n      is_stream\n    })\n  );\n}\nclass FileData {\n  constructor({\n    path,\n    url,\n    orig_name,\n    size,\n    blob,\n    is_stream,\n    mime_type,\n    alt_text,\n    b64\n  }) {\n    __publicField(this, \"path\");\n    __publicField(this, \"url\");\n    __publicField(this, \"orig_name\");\n    __publicField(this, \"size\");\n    __publicField(this, \"blob\");\n    __publicField(this, \"is_stream\");\n    __publicField(this, \"mime_type\");\n    __publicField(this, \"alt_text\");\n    __publicField(this, \"b64\");\n    __publicField(this, \"meta\", { _type: \"gradio.FileData\" });\n    this.path = path;\n    this.url = url;\n    this.orig_name = orig_name;\n    this.size = size;\n    this.blob = url ? void 0 : blob;\n    this.is_stream = is_stream;\n    this.mime_type = mime_type;\n    this.alt_text = alt_text;\n    this.b64 = b64;\n  }\n}\nclass Command {\n  constructor(command, meta) {\n    __publicField(this, \"type\");\n    __publicField(this, \"command\");\n    __publicField(this, \"meta\");\n    __publicField(this, \"fileData\");\n    this.type = \"command\";\n    this.command = command;\n    this.meta = meta;\n  }\n}\nconst is_node = typeof process !== \"undefined\" && process.versions && process.versions.node;\nfunction update_object(object, newValue, stack) {\n  while (stack.length > 1) {\n    const key2 = stack.shift();\n    if (typeof key2 === \"string\" || typeof key2 === \"number\") {\n      object = object[key2];\n    } else {\n      throw new Error(\"Invalid key type\");\n    }\n  }\n  const key = stack.shift();\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    object[key] = newValue;\n  } else {\n    throw new Error(\"Invalid key type\");\n  }\n}\nasync function walk_and_store_blobs(data, type = void 0, path = [], root = false, endpoint_info = void 0) {\n  if (Array.isArray(data)) {\n    let blob_refs = [];\n    await Promise.all(\n      data.map(async (_, index) => {\n        var _a;\n        let new_path = path.slice();\n        new_path.push(String(index));\n        const array_refs = await walk_and_store_blobs(\n          data[index],\n          root ? ((_a = endpoint_info == null ? void 0 : endpoint_info.parameters[index]) == null ? void 0 : _a.component) || void 0 : type,\n          new_path,\n          false,\n          endpoint_info\n        );\n        blob_refs = blob_refs.concat(array_refs);\n      })\n    );\n    return blob_refs;\n  } else if (globalThis.Buffer && data instanceof globalThis.Buffer || data instanceof Blob) {\n    return [\n      {\n        path,\n        blob: new Blob([data]),\n        type\n      }\n    ];\n  } else if (typeof data === \"object\" && data !== null) {\n    let blob_refs = [];\n    for (const key of Object.keys(data)) {\n      const new_path = [...path, key];\n      const value = data[key];\n      blob_refs = blob_refs.concat(\n        await walk_and_store_blobs(\n          value,\n          void 0,\n          new_path,\n          false,\n          endpoint_info\n        )\n      );\n    }\n    return blob_refs;\n  }\n  return [];\n}\nfunction skip_queue(id, config) {\n  var _a, _b;\n  let fn_queue = (_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a.find((dep) => dep.id == id)) == null ? void 0 : _b.queue;\n  if (fn_queue != null) {\n    return !fn_queue;\n  }\n  return !config.enable_queue;\n}\nfunction post_message(message, origin) {\n  return new Promise((res, _rej) => {\n    const channel = new MessageChannel();\n    channel.port1.onmessage = ({ data }) => {\n      channel.port1.close();\n      res(data);\n    };\n    window.parent.postMessage(message, origin, [channel.port2]);\n  });\n}\nfunction handle_file(file_or_url) {\n  if (typeof file_or_url === \"string\") {\n    if (file_or_url.startsWith(\"http://\") || file_or_url.startsWith(\"https://\")) {\n      return {\n        path: file_or_url,\n        url: file_or_url,\n        orig_name: file_or_url.split(\"/\").pop() ?? \"unknown\",\n        meta: { _type: \"gradio.FileData\" }\n      };\n    }\n    if (is_node) {\n      return new Command(\"upload_file\", {\n        path: file_or_url,\n        name: file_or_url,\n        orig_path: file_or_url\n      });\n    }\n  } else if (typeof File !== \"undefined\" && file_or_url instanceof File) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Buffer) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Blob) {\n    return file_or_url;\n  }\n  throw new Error(\n    \"Invalid input: must be a URL, File, Blob, or Buffer object.\"\n  );\n}\nfunction handle_payload(resolved_payload, dependency, components, type, with_null_state = false) {\n  if (type === \"input\" && !with_null_state) {\n    throw new Error(\"Invalid code path. Cannot skip state inputs for input.\");\n  }\n  if (type === \"output\" && with_null_state) {\n    return resolved_payload;\n  }\n  let updated_payload = [];\n  let payload_index = 0;\n  const deps = type === \"input\" ? dependency.inputs : dependency.outputs;\n  for (let i = 0; i < deps.length; i++) {\n    const input_id = deps[i];\n    const component = components.find((c) => c.id === input_id);\n    if ((component == null ? void 0 : component.type) === \"state\") {\n      if (with_null_state) {\n        if (resolved_payload.length === deps.length) {\n          const value = resolved_payload[payload_index];\n          updated_payload.push(value);\n          payload_index++;\n        } else {\n          updated_payload.push(null);\n        }\n      } else {\n        payload_index++;\n        continue;\n      }\n      continue;\n    } else {\n      const value = resolved_payload[payload_index];\n      updated_payload.push(value);\n      payload_index++;\n    }\n  }\n  return updated_payload;\n}\nasync function handle_blob(endpoint, data, api_info) {\n  const self = this;\n  await process_local_file_commands(self, data);\n  const blobRefs = await walk_and_store_blobs(\n    data,\n    void 0,\n    [],\n    true,\n    api_info\n  );\n  const results = await Promise.all(\n    blobRefs.map(async ({ path, blob, type }) => {\n      if (!blob)\n        return { path, type };\n      const response = await self.upload_files(endpoint, [blob]);\n      const file_url = response.files && response.files[0];\n      return {\n        path,\n        file_url,\n        type,\n        name: typeof File !== \"undefined\" && blob instanceof File ? blob == null ? void 0 : blob.name : void 0\n      };\n    })\n  );\n  results.forEach(({ path, file_url, type, name }) => {\n    if (type === \"Gallery\") {\n      update_object(data, file_url, path);\n    } else if (file_url) {\n      const file = new FileData({ path: file_url, orig_name: name });\n      update_object(data, file, path);\n    }\n  });\n  return data;\n}\nasync function process_local_file_commands(client2, data) {\n  var _a, _b;\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  await recursively_process_commands(client2, data);\n}\nasync function recursively_process_commands(client2, data, path = []) {\n  for (const key in data) {\n    if (data[key] instanceof Command) {\n      await process_single_command(client2, data, key);\n    } else if (typeof data[key] === \"object\" && data[key] !== null) {\n      await recursively_process_commands(client2, data[key], [...path, key]);\n    }\n  }\n}\nasync function process_single_command(client2, data, key) {\n  var _a, _b;\n  let cmd_item = data[key];\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  try {\n    let fileBuffer;\n    let fullPath;\n    if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n      const fs = await import(\"fs/promises\");\n      const path = await import(\"path\");\n      fullPath = path.resolve(process.cwd(), cmd_item.meta.path);\n      fileBuffer = await fs.readFile(fullPath);\n    } else {\n      throw new Error(NODEJS_FS_ERROR_MSG);\n    }\n    const file = new Blob([fileBuffer], { type: \"application/octet-stream\" });\n    const response = await client2.upload_files(root, [file]);\n    const file_url = response.files && response.files[0];\n    if (file_url) {\n      const fileData = new FileData({\n        path: file_url,\n        orig_name: cmd_item.meta.name || \"\"\n      });\n      data[key] = fileData;\n    }\n  } catch (error) {\n    console.error(FILE_PROCESSING_ERROR_MSG, error);\n  }\n}\nasync function post_data(url, body, additional_headers) {\n  const headers = { \"Content-Type\": \"application/json\" };\n  if (this.options.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  try {\n    var response = await this.fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: { ...headers, ...additional_headers },\n      credentials: \"include\"\n    });\n  } catch (e) {\n    return [{ error: BROKEN_CONNECTION_MSG }, 500];\n  }\n  let output;\n  let status;\n  try {\n    output = await response.json();\n    status = response.status;\n  } catch (e) {\n    output = { error: `Could not parse server response: ${e}` };\n    status = 500;\n  }\n  return [output, status];\n}\nasync function predict(endpoint, data = {}) {\n  let data_returned = false;\n  let status_complete = false;\n  if (!this.config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  if (typeof endpoint === \"number\") {\n    this.config.dependencies.find((dep) => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    this.config.dependencies.find(\n      (dep) => dep.id == this.api_map[trimmed_endpoint]\n    );\n  }\n  return new Promise(async (resolve, reject) => {\n    const app = this.submit(endpoint, data, null, null, true);\n    let result;\n    for await (const message of app) {\n      if (message.type === \"data\") {\n        if (status_complete) {\n          resolve(result);\n        }\n        data_returned = true;\n        result = message;\n      }\n      if (message.type === \"status\") {\n        if (message.stage === \"error\")\n          reject(message);\n        if (message.stage === \"complete\") {\n          status_complete = true;\n          if (data_returned) {\n            resolve(result);\n          }\n        }\n      }\n    }\n  });\n}\nasync function check_space_status(id, type, status_callback) {\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n  let response;\n  let _status;\n  try {\n    response = await fetch(endpoint);\n    _status = response.status;\n    if (_status !== 200) {\n      throw new Error();\n    }\n    response = await response.json();\n  } catch (e) {\n    status_callback({\n      status: \"error\",\n      load_status: \"error\",\n      message: SPACE_STATUS_ERROR_MSG,\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!response || _status !== 200)\n    return;\n  const {\n    runtime: { stage },\n    id: space_name\n  } = response;\n  switch (stage) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      status_callback({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"PAUSED\":\n      status_callback({\n        status: \"paused\",\n        load_status: \"error\",\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      status_callback({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"Space is running.\",\n        detail: stage\n      });\n      break;\n    case \"BUILDING\":\n      status_callback({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"APP_STARTING\":\n      status_callback({\n        status: \"starting\",\n        load_status: \"pending\",\n        message: \"Space is starting...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    default:\n      status_callback({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n  }\n}\nconst check_and_wake_space = async (space_id, status_callback) => {\n  let retries = 0;\n  const max_retries = 12;\n  const check_interval = 5e3;\n  return new Promise((resolve) => {\n    check_space_status(\n      space_id,\n      RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n      (status) => {\n        status_callback(status);\n        if (status.status === \"running\") {\n          resolve();\n        } else if (status.status === \"error\" || status.status === \"paused\" || status.status === \"space_error\") {\n          resolve();\n        } else if (status.status === \"sleeping\" || status.status === \"building\") {\n          if (retries < max_retries) {\n            retries++;\n            setTimeout(() => {\n              check_and_wake_space(space_id, status_callback).then(resolve);\n            }, check_interval);\n          } else {\n            resolve();\n          }\n        }\n      }\n    );\n  });\n};\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function discussions_enabled(space_id) {\n  try {\n    const r = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/discussions`,\n      {\n        method: \"HEAD\"\n      }\n    );\n    const error = r.headers.get(\"x-error-message\");\n    if (!r.ok || error && RE_DISABLED_DISCUSSION.test(error))\n      return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function get_space_hardware(space_id, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/${RUNTIME_URL}`,\n      { headers }\n    );\n    if (res.status !== 200)\n      throw new Error(\"Space hardware could not be obtained.\");\n    const { hardware } = await res.json();\n    return hardware.current;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_timeout(space_id, timeout, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const body = {\n    seconds: timeout\n  };\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/${SLEEPTIME_URL}`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\", ...headers },\n        body: JSON.stringify(body)\n      }\n    );\n    if (res.status !== 200) {\n      throw new Error(\n        \"Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges.\"\n      );\n    }\n    const response = await res.json();\n    return response;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nconst hardware_types = [\n  \"cpu-basic\",\n  \"cpu-upgrade\",\n  \"cpu-xl\",\n  \"t4-small\",\n  \"t4-medium\",\n  \"a10g-small\",\n  \"a10g-large\",\n  \"a10g-largex2\",\n  \"a10g-largex4\",\n  \"a100-large\",\n  \"zero-a10g\",\n  \"h100\",\n  \"h100x8\"\n];\nasync function duplicate(app_reference, options) {\n  const { hf_token, private: _private, hardware, timeout, auth } = options;\n  if (hardware && !hardware_types.includes(hardware)) {\n    throw new Error(\n      `Invalid hardware type provided. Valid types are: ${hardware_types.map((v) => `\"${v}\"`).join(\",\")}.`\n    );\n  }\n  const { http_protocol, host } = await process_endpoint(\n    app_reference,\n    hf_token\n  );\n  let cookies = null;\n  if (auth) {\n    const cookie_header = await get_cookie_header(\n      http_protocol,\n      host,\n      auth,\n      fetch\n    );\n    if (cookie_header)\n      cookies = parse_and_set_cookies(cookie_header);\n  }\n  const headers = {\n    Authorization: `Bearer ${hf_token}`,\n    \"Content-Type\": \"application/json\",\n    ...cookies ? { Cookie: cookies.join(\"; \") } : {}\n  };\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n    headers\n  })).json()).name;\n  const space_name = app_reference.split(\"/\")[1];\n  const body = {\n    repository: `${user}/${space_name}`\n  };\n  if (_private) {\n    body.private = true;\n  }\n  let original_hardware;\n  try {\n    if (!hardware) {\n      original_hardware = await get_space_hardware(app_reference, hf_token);\n    }\n  } catch (e) {\n    throw Error(SPACE_METADATA_ERROR_MSG + e.message);\n  }\n  const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n  body.hardware = requested_hardware;\n  try {\n    const response = await fetch(\n      `https://huggingface.co/api/spaces/${app_reference}/duplicate`,\n      {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(body)\n      }\n    );\n    if (response.status === 409) {\n      try {\n        const client2 = await Client.connect(`${user}/${space_name}`, options);\n        return client2;\n      } catch (error) {\n        console.error(\"Failed to connect Client instance:\", error);\n        throw error;\n      }\n    } else if (response.status !== 200) {\n      throw new Error(response.statusText);\n    }\n    const duplicated_space = await response.json();\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n    return await Client.connect(\n      get_space_reference(duplicated_space.url),\n      options\n    );\n  } catch (e) {\n    throw new Error(e);\n  }\n}\nfunction get_space_reference(url) {\n  const regex = /https:\\/\\/huggingface.co\\/spaces\\/([^/]+\\/[^/]+)/;\n  const match = url.match(regex);\n  if (match) {\n    return match[1];\n  }\n}\nclass TextLineStream extends TransformStream {\n  /** Constructs a new instance. */\n  constructor(options = { allowCR: false }) {\n    super({\n      transform: (chars, controller) => {\n        chars = __privateGet(this, _currentLine) + chars;\n        while (true) {\n          const lfIndex = chars.indexOf(\"\\n\");\n          const crIndex = options.allowCR ? chars.indexOf(\"\\r\") : -1;\n          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {\n            controller.enqueue(chars.slice(0, crIndex));\n            chars = chars.slice(crIndex + 1);\n            continue;\n          }\n          if (lfIndex === -1)\n            break;\n          const endIndex = chars[lfIndex - 1] === \"\\r\" ? lfIndex - 1 : lfIndex;\n          controller.enqueue(chars.slice(0, endIndex));\n          chars = chars.slice(lfIndex + 1);\n        }\n        __privateSet(this, _currentLine, chars);\n      },\n      flush: (controller) => {\n        if (__privateGet(this, _currentLine) === \"\")\n          return;\n        const currentLine = options.allowCR && __privateGet(this, _currentLine).endsWith(\"\\r\") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);\n        controller.enqueue(currentLine);\n      }\n    });\n    __privateAdd(this, _currentLine, \"\");\n  }\n}\n_currentLine = new WeakMap();\nfunction stream$1(input) {\n  let decoder = new TextDecoderStream();\n  let split2 = new TextLineStream({ allowCR: true });\n  return input.pipeThrough(decoder).pipeThrough(split2);\n}\nfunction split(input) {\n  let rgx = /[:]\\s*/;\n  let match = rgx.exec(input);\n  let idx = match && match.index;\n  if (idx) {\n    return [\n      input.substring(0, idx),\n      input.substring(idx + match[0].length)\n    ];\n  }\n}\nfunction fallback(headers, key, value) {\n  let tmp = headers.get(key);\n  if (!tmp)\n    headers.set(key, value);\n}\nasync function* events(res, signal) {\n  if (!res.body)\n    return;\n  let iter = stream$1(res.body);\n  let line, reader = iter.getReader();\n  let event;\n  for (; ; ) {\n    if (signal && signal.aborted) {\n      return reader.cancel();\n    }\n    line = await reader.read();\n    if (line.done)\n      return;\n    if (!line.value) {\n      if (event)\n        yield event;\n      event = void 0;\n      continue;\n    }\n    let [field, value] = split(line.value) || [];\n    if (!field)\n      continue;\n    if (field === \"data\") {\n      event || (event = {});\n      event[field] = event[field] ? event[field] + \"\\n\" + value : value;\n    } else if (field === \"event\") {\n      event || (event = {});\n      event[field] = value;\n    } else if (field === \"id\") {\n      event || (event = {});\n      event[field] = +value || value;\n    } else if (field === \"retry\") {\n      event || (event = {});\n      event[field] = +value || void 0;\n    }\n  }\n}\nasync function stream(input, init) {\n  let req = new Request(input, init);\n  fallback(req.headers, \"Accept\", \"text/event-stream\");\n  fallback(req.headers, \"Content-Type\", \"application/json\");\n  let r = await fetch(req);\n  if (!r.ok)\n    throw r;\n  return events(r, req.signal);\n}\nasync function open_stream() {\n  let {\n    event_callbacks,\n    unclosed_events,\n    pending_stream_messages,\n    stream_status,\n    config,\n    jwt\n  } = this;\n  const that = this;\n  if (!config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  stream_status.open = true;\n  let stream2 = null;\n  let params = new URLSearchParams({\n    session_hash: this.session_hash\n  }).toString();\n  let url = new URL(`${config.root}${this.api_prefix}/${SSE_URL}?${params}`);\n  if (jwt) {\n    url.searchParams.set(\"__sign\", jwt);\n  }\n  stream2 = this.stream(url);\n  if (!stream2) {\n    console.warn(\"Cannot connect to SSE endpoint: \" + url.toString());\n    return;\n  }\n  stream2.onmessage = async function(event) {\n    let _data = JSON.parse(event.data);\n    if (_data.msg === \"close_stream\") {\n      close_stream(stream_status, that.abort_controller);\n      return;\n    }\n    const event_id = _data.event_id;\n    if (!event_id) {\n      await Promise.all(\n        Object.keys(event_callbacks).map(\n          (event_id2) => event_callbacks[event_id2](_data)\n        )\n      );\n    } else if (event_callbacks[event_id] && config) {\n      if (_data.msg === \"process_completed\" && [\"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(\n        config.protocol\n      )) {\n        unclosed_events.delete(event_id);\n      }\n      let fn2 = event_callbacks[event_id];\n      if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n        setTimeout(fn2, 0, _data);\n      } else {\n        fn2(_data);\n      }\n    } else {\n      if (!pending_stream_messages[event_id]) {\n        pending_stream_messages[event_id] = [];\n      }\n      pending_stream_messages[event_id].push(_data);\n    }\n  };\n  stream2.onerror = async function() {\n    await Promise.all(\n      Object.keys(event_callbacks).map(\n        (event_id) => event_callbacks[event_id]({\n          msg: \"unexpected_error\",\n          message: BROKEN_CONNECTION_MSG\n        })\n      )\n    );\n  };\n}\nfunction close_stream(stream_status, abort_controller) {\n  if (stream_status) {\n    stream_status.open = false;\n    abort_controller == null ? void 0 : abort_controller.abort();\n  }\n}\nfunction apply_diff_stream(pending_diff_streams, event_id, data) {\n  let is_first_generation = !pending_diff_streams[event_id];\n  if (is_first_generation) {\n    pending_diff_streams[event_id] = [];\n    data.data.forEach((value, i) => {\n      pending_diff_streams[event_id][i] = value;\n    });\n  } else {\n    data.data.forEach((value, i) => {\n      let new_data = apply_diff(pending_diff_streams[event_id][i], value);\n      pending_diff_streams[event_id][i] = new_data;\n      data.data[i] = new_data;\n    });\n  }\n}\nfunction apply_diff(obj, diff) {\n  diff.forEach(([action, path, value]) => {\n    obj = apply_edit(obj, path, action, value);\n  });\n  return obj;\n}\nfunction apply_edit(target, path, action, value) {\n  if (path.length === 0) {\n    if (action === \"replace\") {\n      return value;\n    } else if (action === \"append\") {\n      return target + value;\n    }\n    throw new Error(`Unsupported action: ${action}`);\n  }\n  let current = target;\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]];\n  }\n  const last_path = path[path.length - 1];\n  switch (action) {\n    case \"replace\":\n      current[last_path] = value;\n      break;\n    case \"append\":\n      current[last_path] += value;\n      break;\n    case \"add\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 0, value);\n      } else {\n        current[last_path] = value;\n      }\n      break;\n    case \"delete\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 1);\n      } else {\n        delete current[last_path];\n      }\n      break;\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n  return target;\n}\nfunction readable_stream(input, init = {}) {\n  const instance = {\n    close: () => {\n      console.warn(\"Method not implemented.\");\n    },\n    onerror: null,\n    onmessage: null,\n    onopen: null,\n    readyState: 0,\n    url: input.toString(),\n    withCredentials: false,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n    addEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    dispatchEvent: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    removeEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    }\n  };\n  stream(input, init).then(async (res) => {\n    instance.readyState = instance.OPEN;\n    try {\n      for await (const chunk of res) {\n        instance.onmessage && instance.onmessage(chunk);\n      }\n      instance.readyState = instance.CLOSED;\n    } catch (e) {\n      instance.onerror && instance.onerror(e);\n      instance.readyState = instance.CLOSED;\n    }\n  }).catch((e) => {\n    console.error(e);\n    instance.onerror && instance.onerror(e);\n    instance.readyState = instance.CLOSED;\n  });\n  return instance;\n}\nfunction submit(endpoint, data = {}, event_data, trigger_id, all_events) {\n  var _a;\n  try {\n    let fire_event = function(event) {\n      if (all_events || events_to_publish[event.type]) {\n        push_event(event);\n      }\n    }, close = function() {\n      done = true;\n      while (resolvers.length > 0)\n        resolvers.shift()({\n          value: void 0,\n          done: true\n        });\n    }, push = function(data2) {\n      if (done)\n        return;\n      if (resolvers.length > 0) {\n        resolvers.shift()(data2);\n      } else {\n        values.push(data2);\n      }\n    }, push_error = function(error) {\n      push(thenable_reject(error));\n      close();\n    }, push_event = function(event) {\n      push({ value: event, done: false });\n    }, next = function() {\n      if (values.length > 0)\n        return Promise.resolve(values.shift());\n      if (done)\n        return Promise.resolve({ value: void 0, done: true });\n      return new Promise((resolve) => resolvers.push(resolve));\n    };\n    const { hf_token } = this.options;\n    const {\n      fetch: fetch2,\n      app_reference,\n      config,\n      session_hash,\n      api_info,\n      api_map,\n      stream_status,\n      pending_stream_messages,\n      pending_diff_streams,\n      event_callbacks,\n      unclosed_events,\n      post_data: post_data2,\n      options,\n      api_prefix\n    } = this;\n    const that = this;\n    if (!api_info)\n      throw new Error(\"No API found\");\n    if (!config)\n      throw new Error(\"Could not resolve app config\");\n    let { fn_index, endpoint_info, dependency } = get_endpoint_info(\n      api_info,\n      endpoint,\n      api_map,\n      config\n    );\n    let resolved_data = map_data_to_params(data, endpoint_info);\n    let websocket;\n    let stream2;\n    let protocol = config.protocol ?? \"ws\";\n    let event_id_final = \"\";\n    let event_id_cb = () => event_id_final;\n    const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n    let payload;\n    let event_id = null;\n    let complete = false;\n    let last_status = {};\n    let url_params = typeof window !== \"undefined\" && typeof document !== \"undefined\" ? new URLSearchParams(window.location.search).toString() : \"\";\n    const events_to_publish = ((_a = options == null ? void 0 : options.events) == null ? void 0 : _a.reduce(\n      (acc, event) => {\n        acc[event] = true;\n        return acc;\n      },\n      {}\n    )) || {};\n    async function cancel() {\n      const _status = {\n        stage: \"complete\",\n        queue: false,\n        time: /* @__PURE__ */ new Date()\n      };\n      complete = _status;\n      fire_event({\n        ..._status,\n        type: \"status\",\n        endpoint: _endpoint,\n        fn_index\n      });\n      let reset_request = {};\n      let cancel_request = {};\n      if (protocol === \"ws\") {\n        if (websocket && websocket.readyState === 0) {\n          websocket.addEventListener(\"open\", () => {\n            websocket.close();\n          });\n        } else {\n          websocket.close();\n        }\n        reset_request = { fn_index, session_hash };\n      } else {\n        close_stream(stream_status, that.abort_controller);\n        close();\n        reset_request = { event_id };\n        cancel_request = { event_id, session_hash, fn_index };\n      }\n      try {\n        if (!config) {\n          throw new Error(\"Could not resolve app config\");\n        }\n        if (\"event_id\" in cancel_request) {\n          await fetch2(`${config.root}${api_prefix}/${CANCEL_URL}`, {\n            headers: { \"Content-Type\": \"application/json\" },\n            method: \"POST\",\n            body: JSON.stringify(cancel_request)\n          });\n        }\n        await fetch2(`${config.root}${api_prefix}/${RESET_URL}`, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"POST\",\n          body: JSON.stringify(reset_request)\n        });\n      } catch (e) {\n        console.warn(\n          \"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\"\n        );\n      }\n    }\n    const resolve_heartbeat = async (config2) => {\n      await this._resolve_hearbeat(config2);\n    };\n    async function handle_render_config(render_config) {\n      if (!config)\n        return;\n      let render_id = render_config.render_id;\n      config.components = [\n        ...config.components.filter((c) => c.props.rendered_in !== render_id),\n        ...render_config.components\n      ];\n      config.dependencies = [\n        ...config.dependencies.filter((d) => d.rendered_in !== render_id),\n        ...render_config.dependencies\n      ];\n      const any_state = config.components.some((c) => c.type === \"state\");\n      const any_unload = config.dependencies.some(\n        (d) => d.targets.some((t) => t[1] === \"unload\")\n      );\n      config.connect_heartbeat = any_state || any_unload;\n      await resolve_heartbeat(config);\n      fire_event({\n        type: \"render\",\n        data: render_config,\n        endpoint: _endpoint,\n        fn_index\n      });\n    }\n    this.handle_blob(config.root, resolved_data, endpoint_info).then(\n      async (_payload) => {\n        var _a2;\n        let input_data = handle_payload(\n          _payload,\n          dependency,\n          config.components,\n          \"input\",\n          true\n        );\n        payload = {\n          data: input_data || [],\n          event_data,\n          fn_index,\n          trigger_id\n        };\n        if (skip_queue(fn_index, config)) {\n          fire_event({\n            type: \"status\",\n            endpoint: _endpoint,\n            stage: \"pending\",\n            queue: false,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          post_data2(\n            `${config.root}${api_prefix}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`,\n            {\n              ...payload,\n              session_hash\n            }\n          ).then(([output, status_code]) => {\n            const data2 = output.data;\n            if (status_code == 200) {\n              fire_event({\n                type: \"data\",\n                endpoint: _endpoint,\n                fn_index,\n                data: handle_payload(\n                  data2,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                time: /* @__PURE__ */ new Date(),\n                event_data,\n                trigger_id\n              });\n              if (output.render_config) {\n                handle_render_config(output.render_config);\n              }\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                stage: \"complete\",\n                eta: output.average_duration,\n                queue: false,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                endpoint: _endpoint,\n                fn_index,\n                message: output.error,\n                queue: false,\n                time: /* @__PURE__ */ new Date()\n              });\n            }\n          }).catch((e) => {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: e.message,\n              endpoint: _endpoint,\n              fn_index,\n              queue: false,\n              time: /* @__PURE__ */ new Date()\n            });\n          });\n        } else if (protocol == \"ws\") {\n          const { ws_protocol, host } = await process_endpoint(\n            app_reference,\n            hf_token\n          );\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          let url = new URL(\n            `${ws_protocol}://${resolve_root(\n              host,\n              config.path,\n              true\n            )}/queue/join${url_params ? \"?\" + url_params : \"\"}`\n          );\n          if (this.jwt) {\n            url.searchParams.set(\"__sign\", this.jwt);\n          }\n          websocket = new WebSocket(url);\n          websocket.onclose = (evt) => {\n            if (!evt.wasClean) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                broken: true,\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            }\n          };\n          websocket.onmessage = function(event) {\n            const _data = JSON.parse(event.data);\n            const { type, status, data: data2 } = handle_message(\n              _data,\n              last_status[fn_index]\n            );\n            if (type === \"update\" && status && !complete) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date(),\n                ...status\n              });\n              if (status.stage === \"error\") {\n                websocket.close();\n              }\n            } else if (type === \"hash\") {\n              websocket.send(JSON.stringify({ fn_index, session_hash }));\n              return;\n            } else if (type === \"data\") {\n              websocket.send(JSON.stringify({ ...payload, session_hash }));\n            } else if (type === \"complete\") {\n              complete = status;\n            } else if (type === \"log\") {\n              fire_event({\n                type: \"log\",\n                title: data2.title,\n                log: data2.log,\n                level: data2.level,\n                endpoint: _endpoint,\n                duration: data2.duration,\n                visible: data2.visible,\n                fn_index\n              });\n            } else if (type === \"generating\") {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */ new Date(),\n                ...status,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n            }\n            if (data2) {\n              fire_event({\n                type: \"data\",\n                time: /* @__PURE__ */ new Date(),\n                data: handle_payload(\n                  data2.data,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                endpoint: _endpoint,\n                fn_index,\n                event_data,\n                trigger_id\n              });\n              if (complete) {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */ new Date(),\n                  ...complete,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                websocket.close();\n              }\n            }\n          };\n          if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\n            addEventListener(\n              \"open\",\n              () => websocket.send(JSON.stringify({ hash: session_hash }))\n            );\n          }\n        } else if (protocol == \"sse\") {\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          var params = new URLSearchParams({\n            fn_index: fn_index.toString(),\n            session_hash\n          }).toString();\n          let url = new URL(\n            `${config.root}${api_prefix}/${SSE_URL}?${url_params ? url_params + \"&\" : \"\"}${params}`\n          );\n          if (this.jwt) {\n            url.searchParams.set(\"__sign\", this.jwt);\n          }\n          stream2 = this.stream(url);\n          if (!stream2) {\n            return Promise.reject(\n              new Error(\"Cannot connect to SSE endpoint: \" + url.toString())\n            );\n          }\n          stream2.onmessage = async function(event) {\n            const _data = JSON.parse(event.data);\n            const { type, status, data: data2 } = handle_message(\n              _data,\n              last_status[fn_index]\n            );\n            if (type === \"update\" && status && !complete) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date(),\n                ...status\n              });\n              if (status.stage === \"error\") {\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            } else if (type === \"data\") {\n              let [_, status2] = await post_data2(\n                `${config.root}${api_prefix}/queue/data`,\n                {\n                  ...payload,\n                  session_hash,\n                  event_id\n                }\n              );\n              if (status2 !== 200) {\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: BROKEN_CONNECTION_MSG,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */ new Date()\n                });\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            } else if (type === \"complete\") {\n              complete = status;\n            } else if (type === \"log\") {\n              fire_event({\n                type: \"log\",\n                title: data2.title,\n                log: data2.log,\n                level: data2.level,\n                endpoint: _endpoint,\n                duration: data2.duration,\n                visible: data2.visible,\n                fn_index\n              });\n            } else if (type === \"generating\" || type === \"streaming\") {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */ new Date(),\n                ...status,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n            }\n            if (data2) {\n              fire_event({\n                type: \"data\",\n                time: /* @__PURE__ */ new Date(),\n                data: handle_payload(\n                  data2.data,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                endpoint: _endpoint,\n                fn_index,\n                event_data,\n                trigger_id\n              });\n              if (complete) {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */ new Date(),\n                  ...complete,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            }\n          };\n        } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\" || protocol == \"sse_v3\") {\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          let hostname = \"\";\n          if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n            hostname = (_a2 = window == null ? void 0 : window.location) == null ? void 0 : _a2.hostname;\n          }\n          let hfhubdev = \"dev.spaces.huggingface.tech\";\n          const origin = hostname.includes(\".dev.\") ? `https://moon-${hostname.split(\".\")[1]}.${hfhubdev}` : `https://huggingface.co`;\n          const is_zerogpu_iframe = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.parent != window && window.supports_zerogpu_headers;\n          const zerogpu_auth_promise = is_zerogpu_iframe ? post_message(\"zerogpu-headers\", origin) : Promise.resolve(null);\n          const post_data_promise = zerogpu_auth_promise.then((headers) => {\n            return post_data2(\n              `${config.root}${api_prefix}/${SSE_DATA_URL}?${url_params}`,\n              {\n                ...payload,\n                session_hash\n              },\n              headers\n            );\n          });\n          post_data_promise.then(async ([response, status]) => {\n            if (status === 503) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: QUEUE_FULL_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else if (status !== 200) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else {\n              event_id = response.event_id;\n              event_id_final = event_id;\n              let callback = async function(_data) {\n                try {\n                  const { type, status: status2, data: data2, original_msg } = handle_message(\n                    _data,\n                    last_status[fn_index]\n                  );\n                  if (type == \"heartbeat\") {\n                    return;\n                  }\n                  if (type === \"update\" && status2 && !complete) {\n                    fire_event({\n                      type: \"status\",\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date(),\n                      original_msg,\n                      ...status2\n                    });\n                  } else if (type === \"complete\") {\n                    complete = status2;\n                  } else if (type == \"unexpected_error\") {\n                    console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                    fire_event({\n                      type: \"status\",\n                      stage: \"error\",\n                      message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date()\n                    });\n                  } else if (type === \"log\") {\n                    fire_event({\n                      type: \"log\",\n                      title: data2.title,\n                      log: data2.log,\n                      level: data2.level,\n                      endpoint: _endpoint,\n                      duration: data2.duration,\n                      visible: data2.visible,\n                      fn_index\n                    });\n                    return;\n                  } else if (type === \"generating\" || type === \"streaming\") {\n                    fire_event({\n                      type: \"status\",\n                      time: /* @__PURE__ */ new Date(),\n                      ...status2,\n                      stage: status2 == null ? void 0 : status2.stage,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    if (data2 && dependency.connection !== \"stream\" && [\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                      apply_diff_stream(pending_diff_streams, event_id, data2);\n                    }\n                  }\n                  if (data2) {\n                    fire_event({\n                      type: \"data\",\n                      time: /* @__PURE__ */ new Date(),\n                      data: handle_payload(\n                        data2.data,\n                        dependency,\n                        config.components,\n                        \"output\",\n                        options.with_null_state\n                      ),\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    if (data2.render_config) {\n                      await handle_render_config(data2.render_config);\n                    }\n                    if (complete) {\n                      fire_event({\n                        type: \"status\",\n                        time: /* @__PURE__ */ new Date(),\n                        ...complete,\n                        stage: status2 == null ? void 0 : status2.stage,\n                        queue: true,\n                        endpoint: _endpoint,\n                        fn_index\n                      });\n                      close();\n                    }\n                  }\n                  if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                    if (event_callbacks[event_id]) {\n                      delete event_callbacks[event_id];\n                    }\n                    if (event_id in pending_diff_streams) {\n                      delete pending_diff_streams[event_id];\n                    }\n                  }\n                } catch (e) {\n                  console.error(\"Unexpected client exception\", e);\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: \"An Unexpected Error Occurred!\",\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                  if ([\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                    close_stream(stream_status, that.abort_controller);\n                    stream_status.open = false;\n                    close();\n                  }\n                }\n              };\n              if (event_id in pending_stream_messages) {\n                pending_stream_messages[event_id].forEach(\n                  (msg) => callback(msg)\n                );\n                delete pending_stream_messages[event_id];\n              }\n              event_callbacks[event_id] = callback;\n              unclosed_events.add(event_id);\n              if (!stream_status.open) {\n                await this.open_stream();\n              }\n            }\n          });\n        }\n      }\n    );\n    let done = false;\n    const values = [];\n    const resolvers = [];\n    const iterator = {\n      [Symbol.asyncIterator]: () => iterator,\n      next,\n      throw: async (value) => {\n        push_error(value);\n        return next();\n      },\n      return: async () => {\n        close();\n        return next();\n      },\n      cancel,\n      event_id: event_id_cb\n    };\n    return iterator;\n  } catch (error) {\n    console.error(\"Submit function encountered an error:\", error);\n    throw error;\n  }\n}\nfunction thenable_reject(error) {\n  return {\n    then: (resolve, reject) => reject(error)\n  };\n}\nfunction get_endpoint_info(api_info, endpoint, api_map, config) {\n  let fn_index;\n  let endpoint_info;\n  let dependency;\n  if (typeof endpoint === \"number\") {\n    fn_index = endpoint;\n    endpoint_info = api_info.unnamed_endpoints[fn_index];\n    dependency = config.dependencies.find((dep) => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    fn_index = api_map[trimmed_endpoint];\n    endpoint_info = api_info.named_endpoints[endpoint.trim()];\n    dependency = config.dependencies.find(\n      (dep) => dep.id == api_map[trimmed_endpoint]\n    );\n  }\n  if (typeof fn_index !== \"number\") {\n    throw new Error(\n      \"There is no endpoint matching that name of fn_index matching that number.\"\n    );\n  }\n  return { fn_index, endpoint_info, dependency };\n}\nclass Client {\n  constructor(app_reference, options = { events: [\"data\"] }) {\n    __publicField(this, \"app_reference\");\n    __publicField(this, \"options\");\n    __publicField(this, \"deep_link\", null);\n    __publicField(this, \"config\");\n    __publicField(this, \"api_prefix\", \"\");\n    __publicField(this, \"api_info\");\n    __publicField(this, \"api_map\", {});\n    __publicField(this, \"session_hash\", Math.random().toString(36).substring(2));\n    __publicField(this, \"jwt\", false);\n    __publicField(this, \"last_status\", {});\n    __publicField(this, \"cookies\", null);\n    // streaming\n    __publicField(this, \"stream_status\", { open: false });\n    __publicField(this, \"closed\", false);\n    __publicField(this, \"pending_stream_messages\", {});\n    __publicField(this, \"pending_diff_streams\", {});\n    __publicField(this, \"event_callbacks\", {});\n    __publicField(this, \"unclosed_events\", /* @__PURE__ */ new Set());\n    __publicField(this, \"heartbeat_event\", null);\n    __publicField(this, \"abort_controller\", null);\n    __publicField(this, \"stream_instance\", null);\n    __publicField(this, \"current_payload\");\n    __publicField(this, \"ws_map\", {});\n    __publicField(this, \"view_api\");\n    __publicField(this, \"upload_files\");\n    __publicField(this, \"upload\");\n    __publicField(this, \"handle_blob\");\n    __publicField(this, \"post_data\");\n    __publicField(this, \"submit\");\n    __publicField(this, \"predict\");\n    __publicField(this, \"open_stream\");\n    __publicField(this, \"resolve_config\");\n    __publicField(this, \"resolve_cookies\");\n    var _a;\n    this.app_reference = app_reference;\n    this.deep_link = ((_a = options.query_params) == null ? void 0 : _a.deep_link) || null;\n    if (!options.events) {\n      options.events = [\"data\"];\n    }\n    this.options = options;\n    this.current_payload = {};\n    this.view_api = view_api.bind(this);\n    this.upload_files = upload_files.bind(this);\n    this.handle_blob = handle_blob.bind(this);\n    this.post_data = post_data.bind(this);\n    this.submit = submit.bind(this);\n    this.predict = predict.bind(this);\n    this.open_stream = open_stream.bind(this);\n    this.resolve_config = resolve_config.bind(this);\n    this.resolve_cookies = resolve_cookies.bind(this);\n    this.upload = upload.bind(this);\n    this.fetch = this.fetch.bind(this);\n    this.handle_space_success = this.handle_space_success.bind(this);\n    this.stream = this.stream.bind(this);\n  }\n  get_url_config(url = null) {\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    if (url === null) {\n      url = window.location.href;\n    }\n    const stripSlashes = (str) => str.replace(/^\\/+|\\/+$/g, \"\");\n    let root_path = stripSlashes(new URL(this.config.root).pathname);\n    let url_path = stripSlashes(new URL(url).pathname);\n    let page;\n    if (!url_path.startsWith(root_path)) {\n      page = \"\";\n    } else {\n      page = stripSlashes(url_path.substring(root_path.length));\n    }\n    return this.get_page_config(page);\n  }\n  get_page_config(page) {\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    let config = this.config;\n    if (!(page in config.page)) {\n      page = \"\";\n    }\n    return {\n      ...config,\n      current_page: page,\n      layout: config.page[page].layout,\n      components: config.components.filter(\n        (c) => config.page[page].components.includes(c.id)\n      ),\n      dependencies: this.config.dependencies.filter(\n        (d) => config.page[page].dependencies.includes(d.id)\n      )\n    };\n  }\n  fetch(input, init) {\n    const headers = new Headers((init == null ? void 0 : init.headers) || {});\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    if (this && this.options.headers) {\n      for (const name in this.options.headers) {\n        headers.append(name, this.options.headers[name]);\n      }\n    }\n    return fetch(input, { ...init, headers });\n  }\n  stream(url) {\n    const headers = new Headers();\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    if (this && this.options.headers) {\n      for (const name in this.options.headers) {\n        headers.append(name, this.options.headers[name]);\n      }\n    }\n    this.abort_controller = new AbortController();\n    this.stream_instance = readable_stream(url.toString(), {\n      credentials: \"include\",\n      headers,\n      signal: this.abort_controller.signal\n    });\n    return this.stream_instance;\n  }\n  async init() {\n    var _a;\n    if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.WebSocket) {\n      const ws = await import(\"./wrapper-CviSselG.js\");\n      global.WebSocket = ws.WebSocket;\n    }\n    if (this.options.auth) {\n      await this.resolve_cookies();\n    }\n    await this._resolve_config().then(\n      ({ config }) => this._resolve_hearbeat(config)\n    );\n    this.api_info = await this.view_api();\n    this.api_map = map_names_to_ids(((_a = this.config) == null ? void 0 : _a.dependencies) || []);\n  }\n  async _resolve_hearbeat(_config) {\n    if (_config) {\n      this.config = _config;\n      this.api_prefix = _config.api_prefix || \"\";\n      if (this.config && this.config.connect_heartbeat) {\n        if (this.config.space_id && this.options.hf_token) {\n          this.jwt = await get_jwt(\n            this.config.space_id,\n            this.options.hf_token,\n            this.cookies\n          );\n        }\n      }\n    }\n    if (_config.space_id && this.options.hf_token) {\n      this.jwt = await get_jwt(_config.space_id, this.options.hf_token);\n    }\n    if (this.config && this.config.connect_heartbeat) {\n      const heartbeat_url = new URL(\n        `${this.config.root}${this.api_prefix}/${HEARTBEAT_URL}/${this.session_hash}`\n      );\n      if (this.jwt) {\n        heartbeat_url.searchParams.set(\"__sign\", this.jwt);\n      }\n      if (!this.heartbeat_event) {\n        this.heartbeat_event = this.stream(heartbeat_url);\n      }\n    }\n  }\n  static async connect(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    const client2 = new this(app_reference, options);\n    await client2.init();\n    return client2;\n  }\n  close() {\n    this.closed = true;\n    close_stream(this.stream_status, this.abort_controller);\n  }\n  set_current_payload(payload) {\n    this.current_payload = payload;\n  }\n  static async duplicate(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    return duplicate(app_reference, options);\n  }\n  async _resolve_config() {\n    const { http_protocol, host, space_id } = await process_endpoint(\n      this.app_reference,\n      this.options.hf_token\n    );\n    const { status_callback } = this.options;\n    if (space_id && status_callback) {\n      await check_and_wake_space(space_id, status_callback);\n    }\n    let config;\n    try {\n      let configUrl = `${http_protocol}//${host}`;\n      config = await this.resolve_config(configUrl);\n      if (!config) {\n        throw new Error(CONFIG_ERROR_MSG);\n      }\n      return this.config_success(config);\n    } catch (e) {\n      if (space_id && status_callback) {\n        check_space_status(\n          space_id,\n          RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n          this.handle_space_success\n        );\n      } else {\n        if (status_callback)\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        throw Error(e);\n      }\n    }\n  }\n  async config_success(_config) {\n    this.config = _config;\n    this.api_prefix = _config.api_prefix || \"\";\n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n      if (window.location.protocol === \"https:\") {\n        this.config.root = this.config.root.replace(\"http://\", \"https://\");\n      }\n    }\n    if (this.config.auth_required) {\n      return this.prepare_return_obj();\n    }\n    try {\n      this.api_info = await this.view_api();\n    } catch (e) {\n      console.error(API_INFO_ERROR_MSG + e.message);\n    }\n    return this.prepare_return_obj();\n  }\n  async handle_space_success(status) {\n    var _a;\n    if (!this) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const { status_callback } = this.options;\n    if (status_callback)\n      status_callback(status);\n    if (status.status === \"running\") {\n      try {\n        this.config = await this._resolve_config();\n        this.api_prefix = ((_a = this == null ? void 0 : this.config) == null ? void 0 : _a.api_prefix) || \"\";\n        if (!this.config) {\n          throw new Error(CONFIG_ERROR_MSG);\n        }\n        const _config = await this.config_success(this.config);\n        return _config;\n      } catch (e) {\n        if (status_callback) {\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        }\n        throw e;\n      }\n    }\n  }\n  async component_server(component_id, fn_name, data) {\n    var _a;\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const headers = {};\n    const { hf_token } = this.options;\n    const { session_hash } = this;\n    if (hf_token) {\n      headers.Authorization = `Bearer ${this.options.hf_token}`;\n    }\n    let root_url;\n    let component = this.config.components.find(\n      (comp) => comp.id === component_id\n    );\n    if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\n      root_url = component.props.root_url;\n    } else {\n      root_url = this.config.root;\n    }\n    let body;\n    if (\"binary\" in data) {\n      body = new FormData();\n      for (const key in data.data) {\n        if (key === \"binary\")\n          continue;\n        body.append(key, data.data[key]);\n      }\n      body.set(\"component_id\", component_id.toString());\n      body.set(\"fn_name\", fn_name);\n      body.set(\"session_hash\", session_hash);\n    } else {\n      body = JSON.stringify({\n        data,\n        component_id,\n        fn_name,\n        session_hash\n      });\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    if (hf_token) {\n      headers.Authorization = `Bearer ${hf_token}`;\n    }\n    try {\n      const response = await this.fetch(\n        `${root_url}${this.api_prefix}/${COMPONENT_SERVER_URL}/`,\n        {\n          method: \"POST\",\n          body,\n          headers,\n          credentials: \"include\"\n        }\n      );\n      if (!response.ok) {\n        throw new Error(\n          \"Could not connect to component server: \" + response.statusText\n        );\n      }\n      const output = await response.json();\n      return output;\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  set_cookies(raw_cookies) {\n    this.cookies = parse_and_set_cookies(raw_cookies).join(\"; \");\n  }\n  prepare_return_obj() {\n    return {\n      config: this.config,\n      predict: this.predict,\n      submit: this.submit,\n      view_api: this.view_api,\n      component_server: this.component_server\n    };\n  }\n  async connect_ws(url) {\n    return new Promise((resolve, reject) => {\n      let ws;\n      try {\n        ws = new WebSocket(url);\n      } catch (e) {\n        this.ws_map[url] = \"failed\";\n        return;\n      }\n      ws.onopen = () => {\n        resolve();\n      };\n      ws.onerror = (error) => {\n        console.error(\"WebSocket error:\", error);\n        this.close_ws(url);\n        this.ws_map[url] = \"failed\";\n        resolve();\n      };\n      ws.onclose = () => {\n        delete this.ws_map[url];\n        this.ws_map[url] = \"failed\";\n      };\n      ws.onmessage = (event) => {\n      };\n      this.ws_map[url] = ws;\n    });\n  }\n  async send_ws_message(url, data) {\n    if (!(url in this.ws_map)) {\n      await this.connect_ws(url);\n    }\n    const ws = this.ws_map[url];\n    if (ws instanceof WebSocket) {\n      ws.send(JSON.stringify(data));\n    } else {\n      this.post_data(url, data);\n    }\n  }\n  async close_ws(url) {\n    if (url in this.ws_map) {\n      const ws = this.ws_map[url];\n      if (ws instanceof WebSocket) {\n        ws.close();\n        delete this.ws_map[url];\n      }\n    }\n  }\n}\nasync function client(app_reference, options = {\n  events: [\"data\"]\n}) {\n  return await Client.connect(app_reference, options);\n}\nasync function duplicate_space(app_reference, options) {\n  return await Client.duplicate(app_reference, options);\n}\nexport {\n  Client,\n  FileData,\n  client,\n  duplicate_space as duplicate,\n  handle_file,\n  predict,\n  prepare_files,\n  submit,\n  upload,\n  upload_files\n};\n"],"names":["defaultSetTimout","Error","defaultClearTimeout","cachedSetTimeout","cachedClearTimeout","runTimeout","fun","setTimeout","e","call","this","global","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","process","nextTick","args","Array","arguments","i","push","prototype","apply","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","module","exports","_currentLine","__defProp","Object","defineProperty","__publicField","obj","key","value","__defNormalProp","enumerable","configurable","writable","__accessCheck","member","msg","has","TypeError","__privateGet","getter","get","fn","Intl","Collator","numeric","compare","semiver","a","b","bool","split","slice","join","test","HOST_URL","SSE_URL","SSE_DATA_URL","UPLOAD_URL","CONFIG_URL","RESET_URL","CANCEL_URL","QUEUE_FULL_MSG","BROKEN_CONNECTION_MSG","CONFIG_ERROR_MSG","SPACE_METADATA_ERROR_MSG","INVALID_CREDENTIALS_MSG","ROOT_URL_ERROR_MSG","resolve_root","base_url","root_path","prioritize_base","startsWith","async","get_jwt","space","token","cookies","r","fetch","headers","Authorization","Cookie","json","resolve_config","endpoint","_a","options","hf_token","window","gradio_config","location","origin","dev_mode","path","root","config","config_root","config_url","join_urls","deep_link","response","credentials","status","auth","dependencies","forEach","dep","id","resolve_cookies","http_protocol","host","process_endpoint","app_reference","cookie_header","get_cookie_header","set_cookies","message","_fetch","formData","FormData","append","res","method","body","determine_protocol","protocol","pathname","URL","ws_protocol","parse_and_set_cookies","cookie","cookie_name","cookie_value","trim","RE_SPACE_NAME","RE_SPACE_DOMAIN","_app_reference","replace","space_id","_len","urls","_key","reduce","part","toString","get_type","type","component","serializer","signature_type","get_description","description","handle_message","data","last_status","stage","code","success","size","queue_size","position","rank","eta","rank_eta","progress_data","output","error","average_duration","changed_state_ids","time_limit","visible","duration","original_msg","map_data_to_params","undefined","endpoint_info","parameters","isArray","console","warn","resolved_data","provided_keys","keys","param","index","hasOwnProperty","parameter_name","parameter_has_default","parameter_default","some","idx","view_api","api_info","gradio_api_info","JSON","stringify","serialize","url","api_prefix","ok","api","named_endpoints","unnamed_endpoints","api_map","transformed_info","category","entries","_ref2","returns","_b","_c","_d","dependencyIndex","find","api_name","dependencyTypes","types","generator","cancel","inputs","components","map","input","_a2","c","comp","new_param","example","hidden","splice","transform_type","p","transform_api_info","upload_files","root_url","files","upload_id","uploadResponses","chunk","file","upload_url","error_text","text","upload","file_data","max_file_size","file_data2","blob","oversized_files","filter","f","Infinity","Promise","all","then","FileData","prepare_files","is_stream","orig_name","mime_type","constructor","_ref3","alt_text","b64","_type","Command","command","meta","is_node","node","update_object","object","newValue","stack","key2","shift","walk_and_store_blobs","blob_refs","_","new_path","String","array_refs","globalThis","Buffer","Blob","handle_file","file_or_url","pop","orig_path","File","handle_payload","resolved_payload","dependency","with_null_state","updated_payload","payload_index","deps","outputs","input_id","handle_blob","self","client2","recursively_process_commands","process_local_file_commands","blobRefs","_ref5","file_url","_ref6","process_single_command","cmd_item","fileBuffer","fullPath","fs","resolve","readFile","fileData","post_data","additional_headers","predict","data_returned","status_complete","trimmed_endpoint","reject","app","submit","result","check_space_status","status_callback","_status","load_status","detail","runtime","space_name","discussions_enabled","check_and_wake_space","retries","RE_DISABLED_DISCUSSION","hardware_types","duplicate","private","_private","hardware","includes","v","user","repository","original_hardware","current","get_space_hardware","requested_hardware","Client","connect","statusText","duplicated_space","seconds","set_space_timeout","regex","match","get_space_reference","TextLineStream","TransformStream","allowCR","super","transform","chars","controller","lfIndex","indexOf","crIndex","enqueue","endIndex","__privateSet","setter","set","flush","currentLine","endsWith","__privateAdd","WeakSet","add","exec","substring","fallback","events","signal","line","event","reader","decoder","TextDecoderStream","split2","pipeThrough","stream$1","getReader","aborted","read","done","field","open_stream","event_callbacks","unclosed_events","pending_stream_messages","stream_status","jwt","that","open","stream2","params","URLSearchParams","session_hash","searchParams","stream","onmessage","_data","parse","close_stream","abort_controller","event_id","delete","fn2","document","event_id2","onerror","abort","apply_diff_stream","pending_diff_streams","new_data","_ref7","action","target","last_path","Number","apply_edit","readable_stream","init","instance","close","onopen","readyState","withCredentials","CONNECTING","OPEN","CLOSED","addEventListener","dispatchEvent","removeEventListener","req","Request","catch","event_data","trigger_id","all_events","fire_event","events_to_publish","push_event","resolvers","data2","values","push_error","thenable_reject","next","fetch2","post_data2","websocket","fn_index","get_endpoint_info","event_id_final","event_id_cb","_endpoint","payload","complete","url_params","search","acc","time","Date","reset_request","cancel_request","resolve_heartbeat","_resolve_hearbeat","config2","handle_render_config","render_config","render_id","props","rendered_in","d","any_state","any_unload","targets","t","connect_heartbeat","input_data","_payload","fn_queue","enable_queue","skip_queue","_ref8","status_code","WebSocket","onclose","evt","wasClean","broken","send","log","level","hash","status2","hostname","hfhubdev","zerogpu_auth_promise","parent","supports_zerogpu_headers","_rej","channel","MessageChannel","port1","_ref4","postMessage","port2","post_message","_ref9","callback","connection","iterator","Symbol","asyncIterator","throw","return","WeakMap","Math","random","Set","query_params","current_payload","bind","handle_space_success","get_url_config","href","stripSlashes","str","page","url_path","get_page_config","current_page","layout","Headers","AbortController","stream_instance","ws","_resolve_config","_ref10","fns","apis","_ref","map_names_to_ids","_config","heartbeat_url","heartbeat_event","closed","set_current_payload","configUrl","config_success","auth_required","prepare_return_obj","component_server","component_id","fn_name","raw_cookies","connect_ws","ws_map","close_ws","send_ws_message","client","duplicate_space"],"sourceRoot":""}